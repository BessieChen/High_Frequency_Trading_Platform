1. ctp系统架构 
	我们主要涉及:
			交易前置 
			行情服务 
		其他都是后台, 和我们没有关系 
		交易api/行情api:
			上期技术提供给我们的公开接口
	api接口文档清单:
		1. 行情部分 Market data
			1. 核心头文件
				ThostFtdcMdApi.h
			2. 动态链接库, 静态链接库: 支持穿透式监管
				thostmduserapi_se.dll
				thostmduserapi_se.lib
		2. 交易部分 Trader 
			1. 核心文件 
				ThostFtdcTraderApi.h
			2. 动态链接库, 静态链接库: 支持穿透式监管
				thosttraderapi_se.dll
				thosttraderapi_se.lib
		3. 数据结构 
			ThostFtdvUserApiStruct.h 
		4. 数据类型 
			ThostFtdcUserApiDataType.h 
		5. 所有可能的错误信息 
			error.dtd 
			error.xml 
		6. 终端信息采集
			WinDataCollect.dll
			WinDataCollect.lib
	命名规则 
		1. 请求
			 Req 
			 	ReqUserLogin
		2. 响应 
			OnRsp 
				OnRspUserLogin: 回调函数 
		3. 查询 
			ReqQry 
				ReqQryInstrument
		4. 查询请求的响应 
			OnRspQry 
				OOnRspQryInstrument
		5. 回报
			OnRtn 
				OnRtnOrder: 返回下完单之后状态:是委托还是成交了
		6. 错误回报
			OnErrRtn 
				OnErrRtnOrderInsert 
	接口类:
		Api 和 Spi 
			Api: 调用这个类就好了 
			Spi: 实现Api的虚函数 
		CTP:
			CThostFrdcTraderApi 
				apiObj 
			CThostTfdcTraderSpi 
				CUstomizedTraderSpi 
					spiObj 
	初始化的过程:
		1. 行情 
			1. 创建 行情 实例 
			2. 创建 行情回调 实例 
			3. 注册 行情回调类 
			4. 设置行情前置地址 
			5. 启动线程 
		2. 交易接口的初始化 
			1. 创建 交易 实例:{TraderApi 的交易实例}
			2. 创建 交易回调 的实例
			3. 注册 交易回调类
			4. 订阅: 共有流, 私有流 
			5. 注册交易前置地址 
			6. 启动线程
	
2. 可实盘的高频交易系统-架构解析 
	1. 项目目录:
		1. 5个.cpp, 5个 .h 
			1. main 函数, 启动 api 线程 
				1. main.cpp 
				2. main.h 
			2. 行情回调类 
				MDspi.cpp 
				mdspi.h 
			3. 交易回调类 
				Traderspi.cpp 
				traderspi.h 
			4. 策略类 
				strategy.cpp 
				strategy.h 
			5. 结构体, 函数定义类 
				mystruct.cpp 
				mystruct.h 
		5. 5个目录 
			存放 api 文件 
				ThostTraderApi 
			存放行情流文件 
				Temp/Mdflow 
			存放交易流文件 
				Temp/Tdflow 
			存放配置文件 
				Config 
					很简单的 config.txt 
						appid 
						authcode
						product
						userId 
						passwd
						contract
						MarketFront
						TraderFront
			存放行情数据 
				Data 

			存放 exe 文件 
				Bin 
	2. 系统运作流程 
		1. 从主函数 main 开始 
			1. 读取账号信息
				保存到 map(accoutParam_map)
			2. 创建行情 api 的实例 
				1. 行情 
				1. 创建 行情 实例 
				2. 创建 行情回调 实例 
				3. 注册 行情回调类 
				4. 设置行情前置地址 
				5. 启动线程 
			3. 创建交易 api 的实例 
				注意共有流和私有流的订阅模式 
					1. 创建 交易 实例:{TraderApi 的交易实例}
					2. 创建 交易回调 的实例
					3. 注册 交易回调类
					4. 订阅: 共有流, 私有流 
					5. 注册交易前置地址 
					6. 启动线程
			4. 创建策略类实例 
			5. 启动交易 api 线程 
				初始化: 包括穿透验证 + 查询操作 
				1. 会有交易的回调 
				2. 授权 + 回调 
				4. 登录 + 回调
					都是一个请求 + 一个回调
				6. 继续:
					确认下单 + 回调 
					请求查询订单 + 回调 
					请求查询成交 + 回调 
					查询投资者的持仓明细 + 回调 
					查询账户的资金情况 + 回调 
					查询投资者的持仓 Position + 回调  
					查询所有的期货合约 +回调
			6. 启动行情 api 线程 
				连接 + 回调
				登录 + 回调 
				订阅合约信息{订阅行情} + 回调 
					最后把策略类的 Ontick 写在 订阅订阅里面
			7. 故事:
				1. 行情自动推送, 通过行情api,将行情传送给策略类 
				2. 策略类进行逻辑计算: 产生"开仓,平仓撤单"的信号 
				3. 把信号传递给 交易api 执行
				4. 产生的交易结果, 通过回调函数自动返回
					交易api将结果传回给策略类, 更新相关信息 
				行情继续推送, 重复直至收盘 
			8. 启动AI交互线程 
			9. 等待行情,交易,AI线程最后退出 
3. 穿透监管测试
	1. 和柜台连接, 会调用回调函数: OnFrontConnected() 
		打印版本号等信息, 并调用认证 ReqAuthenticate() 
	2. 认证 ReqAuthenticate() 
			复制认证的信息, 其中注意 nRequestID 需要自增, 否则会出现报单错误 
	3. 如果认证成功, 会调用回调函数 OnRspAuthenticate() 
		我们可以通过柜台传递给我们的参数 pRspInfo 来获知是否验证成功
		成功之后, 请求登录 ReqUserLogin() 
4. 穿透监管测试的常见错误
	通过实盘的配置, 测试了:
		当 appid, userid, brokerid, authcode 出错, 柜台会提示什么错误信息
5. 请求账户登录和结算单确认:
	1. 项目是多线程的{多个策略在跑}, 多线程的话, 就要对 nRequestID 进行加锁保护. 之后记得将之前关于 nRequestID++ 的操作修改.  
	2. 实现请求登录函数 ReqUserLogin() 
		登录时候需要的字段, 保存在 CThostFtdReqUserLoginField 结构中. 
	3. 实现请求登录响应 TdSpi.cpp: OnRspUserLogin()
		如果登录成功, 将会调用 OnRspUserLogin()回调函数
		在这个过程中, 我们会获得 frontId 和 sessionId, 以及报单引用 orderRef.
			注意报单引用是递增的. 如果==或者<之前的报单引用会提示重复报单. 
		实现显示错误的函数 IsErrorRspInfo() 其中错误信息保存在 pRspInfo 参数中 
	4. 实现:确认结算单 ReqSettlementInfoConfirm()
		当登录没有问题, 就开始确认结算单. 
		目前是只填写了 m_BrokerId, m_UserId 
		实现 确认结算单的回调函数 OnRspSettlementInfoConfirm() 
			bIsLast: 是否是最后一条信息 
			如果没有错误, 就会打印确认日期 
			接下来, 查询报单, 这个过程中让本线程 sleep()3秒, 为了让柜台有足够的响应时间  
		接下来就是查询报单内容. ReqQryOrder() 
	5. 请求账户登录和结算单确认的常见错误:
		1. brokerId如果错了: errorid{3}, msg{ctp无此权限}
		2. userId如果错了: errorid{3}, msg{ctp不合法的登录} 
		3. password如果错了: errorid{3}, msg{ctp不合法的登录} 
	技术点:
		1. 加锁用mutex,或者lock_guard{在析构的时候解锁}
		2. 注意命名规范! b开头代表bool, p开头代表pointer, m_n代表成员变量且是int型 
		3. 将string拷贝到 const char*, 需要将 string转化为char*, 使用 c_str() 
		4. 让线程休眠, 不建议使用 Sleep() 
			因为 Sleep() 是win自带的, 不利于之后跨os的兼容
			所以休眠使用 std::this_thread::sleep_for() 
6. 查询报单与成交记录
	1. 开启 无限易pro 模拟交易软件
		其他的模拟客户端也可以, 我们只是试着做两笔交易 
		输入 userid, 密码 
		做3笔交易: 买进成交, 卖出成交, 买进成交 
	2. 开始测试: 
		1. 请求查询报单: TdSpi.cpp ReqQryOrder() 
			定义并初始化: 结构体  CThosFtdQryOrderFild 
			初始化主要就是填写 brokerID, investorID. 调用 柜台api 的 ReqQryORder() 
		2. 获取查询报单的内容: OnRspQryOrder()
			调用 ReqQryOrder()如果成功, 程序会走到回调函数 OnRspQryOrder()
				1. 我们可以查看柜台回复给我们的信息, 信息内容保存在 pOrder, pRspInfo 参数中 
				2. pOrder 包括了很多的 frontId, sessionId
				3. m_QryOrder_Once 用于标记是否是第一次查询报单. 
					在构造函数中, 初始化为true, 意思是: 是第一次查询报单
				4. 逻辑:
					本次是第一次查询, m_QryOrder_Once == true, 第一次查询, 有3笔订单的报单:
						1. 第1笔订单: new 一个Order结构体并插入 orderList
						2. 第2笔订单: new 一个Order结构体并插入 orderList
						3. 第3笔订单同时也是最后一笔{bIsLast == true, bIsLast是柜台告诉我们的}: new 一个Order结构体并插入 orderList 
							当是最后一笔订单的时候, 我们会打印 orderList里面的所有订单的信息. 
							并将 m_QryOrder_Once 设置为 false 
							之后会调用 ReqQryTrade() 请求查询成交
		3. 请求查询成交: ReqQryTrade() 
			定义并初始化 CThosFtdQryTradeField 结构体
			之后调用柜台api  ReqQryTrade(), 该函数会填充结构体, 结果体现在回调函数 OnRspQryTrade()的参数中
		4. 获取查询成交的内容: OnRspQryTrade()
			逻辑和上面 OnRspQryOrder()一致 
				1. 我们可以查看柜台回复给我们的信息, 信息内容保存在 pTrade, pRspInfo 参数中 
				2. m_QryTrade_Once 用于标记是否是第一次查询成交. 
					在构造函数中, 初始化为true, 意思是: 是第一次查询成交
				4. 逻辑:
					本次是第一次查询, m_QryTrade_Once == true, 第一次查询, 有3笔订单成交了:
						1. 第1笔订单: new 一个Trade结构体并插入 tradeList
						2. 第2笔订单: new 一个Trade结构体并插入 tradeList
						3. 第3笔订单同时也是最后一笔{bIsLast == true, bIsLast是柜台告诉我们的}: new 一个Trade结构体并插入 tradeList
							当是最后一笔订单的时候, 我们会打印 tradeList里面的所有订单的信息. 
							并将 m_QryTrade_Once 设置为 false 
							之后会调用 ReqQryInvestorPositionDetail() 请求投资者持仓明细 
			注意对比: 
				1. 有报单, 但是该报单不一定成交 
				2. 报单数 >= 成交数. 我们的测试中, 3次报单都成交了 
	3. 查询报单与成交记录的常见错误
		1. ReqQryOrder() 	
			如果 brokerid, investorid 有错误. 不会报错. 但是 pOrder == nullptr 
		2. ReqQryTrade() 	
			如果 brokerid, investorid 有错误. 不会报错. 但是 pTrade == nullptr








	











